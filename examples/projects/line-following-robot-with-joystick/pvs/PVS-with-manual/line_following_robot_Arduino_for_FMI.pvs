line_following_robot_Arduino_for_FMI: THEORY
 BEGIN IMPORTING pvsioweb_utils

 %-- user-defined datatypes
  LightSensorReading: TYPE = { x: nonneg_real | x <= 255 }
  Speed: TYPE = { x: real | x >= 0 AND x <= 255 }
  
  %-- user-defined constants
  IDLE: Speed = 0
  MAX_SPEED: Speed = 255

 

  %-- operating modes
  Mode: TYPE = { Auto, Manual }

  %-- state attributes
  State: TYPE = [#
    mode: Mode,
    previous_mode: Mode,
    backwardRotate: real,
    forwardRotate: real,
    forwardSpeed: real,
    lfLeftVal: real,
    lfRightVal: real,
    LSR_THRESHOLD: real,
    out1: real,
    out2: real,
    out3: real,
    out4: real,
    servoLeftVal: real,
    servoRightVal: real
  #]

  %-- init function
  init: State = (#
    previous_mode := Auto, 
    mode := Auto, 
    backwardRotate := 1.0, 
    forwardRotate := 5.0, 
    forwardSpeed := 4.0, 
    lfLeftVal := 0.0, 
    lfRightVal := 0.0, 
    LSR_THRESHOLD := 400, 
    out1 := 0.0, 
    out2 := 0.0, 
    out3 := 0.0, 
    out4 := 0.0, 
    servoLeftVal := 0.0, 
    servoRightVal := 0.0
  #)

  %-- leave/enter functions
  enter(m: Mode)(st: State): State = st WITH [ mode := m ]
  leave(m: Mode)(st: State): State = st WITH [ previous_mode := m ]

  %-- triggers
  per_accellerate(st: State): bool = (mode(st) = Auto AND ( true ))
    OR (mode(st) = Manual AND ( true ))
  accellerate(st: (per_accellerate)): State =
    COND
     mode(st) = Auto AND ( true )
      -> LET st = leave(Auto)(st),
             st = st WITH [ out1 := 1.0 ],
             st = st WITH [ out2 := 0.0 ],
             st = st WITH [ out3 := 1.0 ],
             st = st WITH [ out4 := 0.0 ],
             st = st WITH [ servoLeftVal := servoLeftVal(st) + 0.1 ],
             st = st WITH [ servoRightVal := servoRightVal(st) + 0.1 ]
          IN enter(Manual)(st),
     mode(st) = Manual AND ( true )
      -> LET st = leave(Manual)(st),
             st = st WITH [ servoLeftVal := servoLeftVal(st) + 0.1 ],
             st = st WITH [ servoRightVal := servoRightVal(st) + 0.1 ],
             st = st WITH [ out1 := 1.0 ],
             st = st WITH [ out2 := 0.0 ],
             st = st WITH [ out3 := 1.0 ],
             st = st WITH [ out4 := 0.0 ]
          IN enter(Manual)(st),
     ELSE -> st
    ENDCOND

  per_autopilot(st: State): bool = (mode(st) = Manual AND ( true ))
  autopilot(st: (per_autopilot)): State =
    COND
     mode(st) = Manual AND ( true )
      -> LET st = leave(Manual)(st),
             st = st WITH [ servoLeftVal := servoLeftVal(st) ],
             st = st WITH [ servoRightVal := servoRightVal(st) ]
          IN enter(Auto)(st),
     ELSE -> st
    ENDCOND

  per_brake(st: State): bool = (mode(st) = Auto AND ( true ))
    OR (mode(st) = Manual AND ( true ))
  brake(st: (per_brake)): State =
    COND
     mode(st) = Auto AND ( true )
      -> LET st = leave(Auto)(st),
             st = st WITH [ out1 := 0.0 ],
             st = st WITH [ out2 := 0.0 ],
             st = st WITH [ out3 := 0.0 ],
             st = st WITH [ out4 := 0.0 ]
          IN enter(Manual)(st),
     mode(st) = Manual AND ( true )
      -> LET st = leave(Manual)(st),
             st = st WITH [ out1 := 0.0 ],
             st = st WITH [ out2 := 0.0 ],
             st = st WITH [ out3 := 0.0 ],
             st = st WITH [ out4 := 0.0 ]
          IN enter(Manual)(st),
     ELSE -> st
    ENDCOND

  per_tick(st: State): bool = (mode(st) = Auto AND ( lfRightVal(st) <= LSR_THRESHOLD(st) AND lfLeftVal(st) <= LSR_THRESHOLD(st) ))
    OR (mode(st) = Auto AND ( lfRightVal(st) <= LSR_THRESHOLD(st) AND lfLeftVal(st) > LSR_THRESHOLD(st) ))
    OR (mode(st) = Auto AND ( lfRightVal(st) > LSR_THRESHOLD(st) AND lfLeftVal(st) <= LSR_THRESHOLD(st) ))
    OR (mode(st) = Auto AND ( lfRightVal(st) > LSR_THRESHOLD(st) AND lfLeftVal(st) > LSR_THRESHOLD(st) ))
    OR (mode(st) = Manual AND ( true ))
  tick(st: (per_tick)): State =
    COND
     mode(st) = Auto AND ( lfRightVal(st) <= LSR_THRESHOLD(st) AND lfLeftVal(st) <= LSR_THRESHOLD(st) )
      -> LET st = leave(Auto)(st),
             st = st WITH [ servoLeftVal := servoLeftVal(st) ],
             st = st WITH [ servoRightVal := servoRightVal(st) ],
             st = st WITH [ out1 := out1(st) ],
             st = st WITH [ out2 := out2(st) ],
             st = st WITH [ out3 := out3(st) ],
             st = st WITH [ out4 := out4(st) ]
          IN enter(Auto)(st),
     mode(st) = Auto AND ( lfRightVal(st) <= LSR_THRESHOLD(st) AND lfLeftVal(st) > LSR_THRESHOLD(st) )
      -> LET st = leave(Auto)(st),
             st = st WITH [ servoLeftVal := forwardRotate(st) ],
             st = st WITH [ servoRightVal := backwardRotate(st) ],
             st = st WITH [ out1 := 0.0 ],
             st = st WITH [ out2 := 1.0 ],
             st = st WITH [ out3 := 1.0 ],
             st = st WITH [ out4 := 0.0 ]
          IN enter(Auto)(st),
     mode(st) = Auto AND ( lfRightVal(st) > LSR_THRESHOLD(st) AND lfLeftVal(st) <= LSR_THRESHOLD(st) )
      -> LET st = leave(Auto)(st),
             st = st WITH [ servoLeftVal := backwardRotate(st) ],
             st = st WITH [ servoRightVal := forwardRotate(st) ],
             st = st WITH [ out1 := 1.0 ],
             st = st WITH [ out2 := 0.0 ],
             st = st WITH [ out3 := 0.0 ],
             st = st WITH [ out4 := 1.0 ]
          IN enter(Auto)(st),
     mode(st) = Auto AND ( lfRightVal(st) > LSR_THRESHOLD(st) AND lfLeftVal(st) > LSR_THRESHOLD(st) )
      -> LET st = leave(Auto)(st),
             st = st WITH [ servoLeftVal := forwardSpeed(st) ],
             st = st WITH [ servoRightVal := forwardSpeed(st) ],
             st = st WITH [ out1 := 1.0 ],
             st = st WITH [ out2 := 0.0 ],
             st = st WITH [ out3 := 1.0 ],
             st = st WITH [ out4 := 0.0 ]
          IN enter(Auto)(st),
     mode(st) = Manual AND ( true )
      -> LET st = leave(Manual)(st),
             st = st WITH [ servoLeftVal := servoLeftVal(st) ],
             st = st WITH [ servoRightVal := servoRightVal(st) ]
          IN enter(Manual)(st),
     ELSE -> st
    ENDCOND

  per_turnLeft(st: State): bool = (mode(st) = Auto AND ( true ))
    OR (mode(st) = Manual AND ( true ))
  turnLeft(st: (per_turnLeft)): State =
    COND
     mode(st) = Auto AND ( true )
      -> LET st = leave(Auto)(st),
             st = st WITH [ out1 := 1.0 ],
             st = st WITH [ out2 := 0.0 ],
             st = st WITH [ out3 := 0.0 ],
             st = st WITH [ out4 := 1.0 ],
             st = st WITH [ servoLeftVal := servoLeftVal(st) + 0.05 ],
             st = st WITH [ servoRightVal := servoRightVal(st) + 0.05 ]
          IN enter(Manual)(st),
     mode(st) = Manual AND ( true )
      -> LET st = leave(Manual)(st),
             st = st WITH [ servoLeftVal := servoLeftVal(st) + 0.05 ],
             st = st WITH [ servoRightVal := servoRightVal(st) + 0.05 ],
             st = st WITH [ out1 := 1.0 ],
             st = st WITH [ out2 := 0.0 ],
             st = st WITH [ out3 := 0.0 ],
             st = st WITH [ out4 := 1.0 ]
          IN enter(Manual)(st),
     ELSE -> st
    ENDCOND

  per_turnRight(st: State): bool = (mode(st) = Auto AND ( true ))
    OR (mode(st) = Manual AND ( true ))
  turnRight(st: (per_turnRight)): State =
    COND
     mode(st) = Auto AND ( true )
      -> LET st = leave(Auto)(st),
             st = st WITH [ out1 := 0.0 ],
             st = st WITH [ out2 := 1.0 ],
             st = st WITH [ out3 := 1.0 ],
             st = st WITH [ out4 := 0.0 ],
             st = st WITH [ servoLeftVal := servoLeftVal(st) + 0.05 ],
             st = st WITH [ servoRightVal := servoRightVal(st) + 0.05 ]
          IN enter(Manual)(st),
     mode(st) = Manual AND ( true )
      -> LET st = leave(Manual)(st),
             st = st WITH [ servoLeftVal := servoLeftVal(st) + 0.05 ],
             st = st WITH [ servoRightVal := servoRightVal(st) + 0.05 ],
             st = st WITH [ out1 := 0.0 ],
             st = st WITH [ out2 := 1.0 ],
             st = st WITH [ out3 := 1.0 ],
             st = st WITH [ out4 := 0.0 ]
          IN enter(Manual)(st),
     ELSE -> st
    ENDCOND

kth_step(K:nat):RECURSIVE State= 
   IF (K=0) THEN
    init
   ELSE
    tick(kth_step(K-1))
   ENDIF
  MEASURE K

hbridge : THEOREM
FORALL(K:nat) : NOT( (out1(kth_step(K))=1 AND out2(kth_step(K))=1) OR (out3(kth_step(K))=1 AND out4(kth_step(K))=1 ) )

%the next one fails because there are 2 possibilities for tick to keep the state: WHITE and WHITE, and manual mode
hbridge_tick_wrong : THEOREM
FORALL (st:State) :  NOT( (out1(tick(st))=1 AND out2(tick(st))=1) OR (out3(tick(st))=1 AND out4(tick(st))=1 ) ) 

%in the next one we added the assumption that the actual state verfies the property of hbridge, therefore the grind succeded
hbridge_tick : THEOREM
FORALL (st:State) :  NOT( (out1(st)=1 AND out2(st)=1) OR (out3(st)=1 AND out4(st)=1 ) ) IMPLIES NOT( (out1(tick(st))=1 AND out2(tick(st))=1) OR (out3(tick(st))=1 AND out4(tick(st))=1 ) ) 

hbridge_accellerate : THEOREM
FORALL (st:State) :  NOT( (out1(accellerate(st))=1 AND out2(accellerate(st))=1) OR (out3(accellerate(st))=1 AND out4(accellerate(st))=1 ) )

hbridge_brake : THEOREM
FORALL (st:State) :  NOT( (out1(brake(st))=1 AND out2(brake(st))=1) OR (out3(brake(st))=1 AND out4(brake(st))=1 ) )

hbridge_turnLeft : THEOREM
FORALL (st:State) :  NOT( (out1(turnLeft(st))=1 AND out2(turnLeft(st))=1) OR (out3(turnLeft(st))=1 AND out4(turnLeft(st))=1 ) )

hbridge_turnRight : THEOREM
FORALL (st:State) :  NOT( (out1(turnRight(st))=1 AND out2(turnRight(st))=1) OR (out3(turnRight(st))=1 AND out4(turnRight(st))=1 ) )

 END line_following_robot_Arduino_for_FMI
