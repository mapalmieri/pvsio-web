line_following_robot_Arduino_for_FMI_no_remote_nocomplete: THEORY
 BEGIN IMPORTING pvsioweb_utils
 

  %-- user-defined datatypes
  LightSensorReading: TYPE = { x: nonneg_real | x <= 255 }
  Speed: TYPE = { x: real | x >= 0 AND x <= 255 }

   %-- user-defined constants
  IDLE: Speed = 0
  MAX_SPEED: Speed = 255
  

  %-- operating modes
  Mode: TYPE = { Auto }

  %-- state attributes
  State: TYPE = [#
    mode: Mode,
    previous_mode: Mode,
    backwardRotate: real,
    forwardRotate: real,
    forwardSpeed: real,
    lfLeftVal: real,
    lfRightVal: real,
    LSR_THRESHOLD: real,
    out1: real,
    out2: real,
    out3: real,
    out4: real,
    servoLeftVal: real,
    servoRightVal: real
  #]

  %-- init function
  init: State = (#
    previous_mode := Auto, 
    mode := Auto, 
    backwardRotate := 1.0, 
    forwardRotate := 5.0, 
    forwardSpeed := 4.0, 
    lfLeftVal := 0.0, 
    lfRightVal := 0.0, 
    LSR_THRESHOLD := 400, 
    out1 := 0.0, 
    out2 := 0.0, 
    out3 := 0.0, 
    out4 := 0.0, 
    servoLeftVal := 0.0, 
    servoRightVal := 0.0
  #)

  %-- leave/enter functions
  enter(m: Mode)(st: State): State = st WITH [ mode := m ]
  leave(m: Mode)(st: State): State = st WITH [ previous_mode := m ]

  %-- triggers
  per_tick(st: State): bool = (mode(st) = Auto AND ( lfRightVal(st) <= LSR_THRESHOLD(st) AND lfLeftVal(st) > LSR_THRESHOLD(st) ))
    OR (mode(st) = Auto AND ( lfRightVal(st) > LSR_THRESHOLD(st) AND lfLeftVal(st) <= LSR_THRESHOLD(st) ))
    OR (mode(st) = Auto AND ( lfRightVal(st) > LSR_THRESHOLD(st) AND lfLeftVal(st) > LSR_THRESHOLD(st) ))
  tick(st: (per_tick)): State =
    COND
     mode(st) = Auto AND ( lfRightVal(st) <= LSR_THRESHOLD(st) AND lfLeftVal(st) > LSR_THRESHOLD(st) )
      -> LET st = leave(Auto)(st),
             st = st WITH [ servoLeftVal := forwardRotate(st) ],
             st = st WITH [ servoRightVal := backwardRotate(st) ],
             st = st WITH [ out1 := 0.0 ],
             st = st WITH [ out2 := 1.0 ],
             st = st WITH [ out3 := 1.0 ],
             st = st WITH [ out4 := 0.0 ]
          IN enter(Auto)(st),
     mode(st) = Auto AND ( lfRightVal(st) > LSR_THRESHOLD(st) AND lfLeftVal(st) <= LSR_THRESHOLD(st) )
      -> LET st = leave(Auto)(st),
             st = st WITH [ servoLeftVal := backwardRotate(st) ],
             st = st WITH [ servoRightVal := forwardRotate(st) ],
             st = st WITH [ out1 := 1.0 ],
             st = st WITH [ out2 := 0.0 ],
             st = st WITH [ out3 := 0.0 ],
             st = st WITH [ out4 := 1.0 ]
          IN enter(Auto)(st),
     mode(st) = Auto AND ( lfRightVal(st) > LSR_THRESHOLD(st) AND lfLeftVal(st) > LSR_THRESHOLD(st) )
      -> LET st = leave(Auto)(st),
             st = st WITH [ servoLeftVal := forwardSpeed(st) ],
             st = st WITH [ servoRightVal := forwardSpeed(st) ],
             st = st WITH [ out1 := 1.0 ],
             st = st WITH [ out2 := 0.0 ],
             st = st WITH [ out3 := 1.0 ],
             st = st WITH [ out4 := 0.0 ]
          IN enter(Auto)(st)
    ENDCOND

kth_step(K:nat):RECURSIVE State= 
   IF (K=0) THEN
    init
   ELSE
    tick(kth_step(K-1))
   ENDIF
  MEASURE K

%the next one fails because there are 2 possibilities for tick to keep the state: WHITE and WHITE, and manual mode
%hbridge_tick_wrong : THEOREM
%FORALL (st:State) :  NOT( (out1(tick(st))=1 AND out2(tick(st))=1) OR (out3(tick(st))=1 AND out4(tick(st))=1 ) ) 

%in the next one we added the assumption that the actual state verfies the property of hbridge, therefore the grind succeded
%hbridge_tick : THEOREM
%FORALL (st:State) :  NOT( (out1(st)=1 AND out2(st)=1) OR (out3(st)=1 AND out4(st)=1 ) ) IMPLIES NOT( (out1(tick(st))=1 AND out2(tick(st))=1) OR (out3(tick(st))=1 AND out4(tick(st))=1 ) ) 

 END line_following_robot_Arduino_for_FMI_no_remote_nocomplete
