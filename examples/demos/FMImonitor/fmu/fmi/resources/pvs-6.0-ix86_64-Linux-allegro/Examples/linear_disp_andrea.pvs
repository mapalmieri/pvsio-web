Linear_displacement_andrea: THEORY
 BEGIN
 %importing reals@sigma_below
 
 N	:	{n:nat | n >= 3};
 
%IMPORTING sigma[below(N)]

 eps	: 	{eps:real | eps > 0 AND  eps < 1};
 min	:	real ;
 max	:	{n:posreal | n > min}	 ;
 j	: VAR nat;
 L	:  posreal =     (max-min)/(N-1);
 i: VAR below[N]
 y: VAR {y:posnat | y<N-1};
 
initial(i:below(N)): real;
init_ax: AXIOM
FORALL (i:below(N-1)): initial(i) < initial(i+1) ;

init_ax_1: AXIOM
initial(0) = min AND initial(N-1) = max ;

init_ax_2: AXIOM
FORALL (i:below(N)): initial(i) <= L*i;

next(x:[below(N)->real]):  [below(N)->real]= LAMBDA i:
IF (i = 0) THEN min
ELSE IF (i = N-1) THEN max
ELSE eps*x(i-1) + (1-2*eps)*x(i) + eps*x(i+1)
ENDIF
ENDIF

kth_step(K:nat):RECURSIVE[below(N)->real]= 
IF (K=0) THEN
initial
ELSE
next(kth_step(K-1))     
ENDIF
MEASURE K

lem_max : LEMMA % uses init_ax_1
 FORALL (k: nat): kth_step(k)(N-1)=max;

lem_min : LEMMA % uses init_ax_1
 FORALL (k: nat): kth_step(k)(0)=min;

lem_1_support_1: LEMMA
kth_step(j)(N-2) < max IMPLIES EXISTS (k1: posreal): max=kth_step(j)(N-2)+k1;

lem_1_support_2: LEMMA
 kth_step(j)(N - 3) < kth_step(j)(N-2) IMPLIES EXISTS (k2: posreal): kth_step(j)(N-2)=kth_step(j)(N - 3)+k2;

lem_1_support_3: LEMMA
 FORALL (k1 : posreal): k1-k1/eps < 0

lem_1: LEMMA % uses lem_1_support_1,lem_1_support_2,lem_1_support_3
kth_step(j)(N-2) < max AND
kth_step(j)(N - 3) < kth_step(j)(N-2)
IMPLIES
kth_step(j)(N - 2) - 2 * (kth_step(j)(N - 2) * eps) + eps * kth_step(j)(N - 3) + eps * max < max

lem_2_support_1: LEMMA
min < kth_step(j)(1) IMPLIES EXISTS (k1 : posreal): kth_step(j)(1)=min +k1;

lem_2_support_2: LEMMA
 kth_step(j)(1) <  kth_step(j)(2) IMPLIES EXISTS (k2 : posreal):  kth_step(j)(2)= kth_step(j)(1)+k2;

lem_2_support_3: LEMMA
FORALL (k1:posreal): eps * k1 - k1<0;

lem_2: LEMMA %uses lem_2_support_1,lem_2_support_2,lem_2_support_3
min < kth_step(j)(1)  AND
kth_step(j)(1) <  kth_step(j)(2)
IMPLIES
min < kth_step(j)(1) - 2 * (kth_step(j)(1) * eps) + eps * min + eps * kth_step(j)(2)

% a < a' <b
lem_4: LEMMA
i<N-2 AND
i/=0 AND
%a' < b
kth_step(j)(i-1)+ kth_step(j)(i+1)*(1/eps -3) <  kth_step(j)(i+2)+ kth_step(j)(i+1)*(1/eps -3) AND
%a<a'
kth_step(j)(i-1)+ kth_step(j)(i)*(1/eps -3) <= kth_step(j)(i-1)+ kth_step(j)(i+1)*(1/eps -3) 
IMPLIES
%a<b
kth_step(j)(i-1)+ kth_step(j)(i)*(1/eps -3) <  kth_step(j)(i+2)+ kth_step(j)(i+1)*(1/eps -3)

simple: LEMMA
eps <= 1/3 AND  kth_step(j)(i) < kth_step(j)(i + 1) IMPLIES next(kth_step(j))(i) < next(kth_step(j))(i+1)
 
no_cross: THEOREM %uses init_ax,lem_2,lem_min,lem_1,lem_max,lem_4,
eps<=1/3 IMPLIES
        FORALL (k: nat):FORALL (i:{ n:nat | n < N-1}): kth_step(k)(i) < kth_step(k)(i+1)

%a<=a'<=b
lem_conv_1: LEMMA
 i /= 0 AND i /= N-1 IMPLIES
FORALL (k:nat): kth_step(k)(i-1) <= L*(i-1) AND kth_step(k)(i) <= L*(i) AND kth_step(k)(i+1) <= L*(i+1)
 %a <= a'
 AND kth_step(k+1)(i) <=  kth_step(k)(i) + eps*(L*i -L + L*i+L -2*kth_step(k)(i))
 %a' <= b
 AND  kth_step(k)(i) + eps*(L*i -L + L*i+L -2*kth_step(k)(i))<=L*i
 IMPLIES
 %a<=b
  kth_step(k+1)(i)<=L*i

convergence_support: THEOREM %uses init_ax_2,lem_min,lem_max,lem_conv_1
min=0 AND eps<1/2 IMPLIES
FORALL (k:nat):FORALL (i:{ n:nat | n < N}): kth_step(k)(i) <= L*i

%lem_alt : LEMMA 
%FORALL (k:nat): FORALL (n:above(2)| n-1<N):
%sigma(1, n - 2, next(kth_step(k))) =
%       sigma(1, n - 2, kth_step(k)) +
%        eps *
%         ((kth_step(k)(n - 1) - kth_step(k)(n - 2)) -
%           (kth_step(k)(1) - kth_step(k)(0)));
	   

%lem_sum : LEMMA %uses lem_alt
%FORALL ( k : nat) : sigma(1,N-2,kth_step(k+1)) =  sigma(1,N-2,kth_step(k)) + eps*(( kth_step(k)(N-1)-kth_step(k)(N-2))-(kth_step(k)(1)-kth_step(k)(0)));

%convergence_support_1  : THEOREM % uses lem_min, lem_max, lem_alt, convergence_support, 
%min=0 AND eps<1/2 IMPLIES
%FORALL ( k: nat) : sigma(0,N-1,kth_step(k+1)) >= sigma(0,N-1,kth_step(k));

END Linear_displacement_andrea
