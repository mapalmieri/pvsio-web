line_following_robot_Arduino_for_FMI: THEORY
 BEGIN 
 
  %-- user-defined types
  Speed: TYPE = { x: real | x >= 0 AND x <= 255 }
  LightSensorReading: TYPE = { x: nonneg_real | x <= 255 }
 
  %-- user-defined constants
  LSR_THRESHOLD: real = 150.0
  IDLE: Speed = 0
  MAX_SPEED: Speed = 255

  %-- utility functions
  inc_speed(s: Speed, x: nonneg_real): Speed =
  IF s + x < MAX_SPEED THEN s + x ELSE MAX_SPEED ENDIF
   
  dec_speed(s: Speed, x: nonneg_real): Speed =
       IF s - x > IDLE THEN s - x ELSE IDLE ENDIF
      
   
  %-- operating modes
  Mode: TYPE = { Auto, Manual }

  %-- state attributes
  State: TYPE = [#
    mode: Mode,
    previous_mode: Mode,
    backwardRotate: Speed,
    forwardRotate: Speed,
    forwardSpeed: Speed,
    lfLeftVal: LightSensorReading,
    lfRightVal: LightSensorReading,
    out1: real,
    out2: real,
    out3: real,
    out4: real,
    servoLeftVal: Speed,
    servoRightVal: Speed
  #]

  %-- init function
  init: State = (#
    mode := Auto, 
    previous_mode := Auto, 
    backwardRotate := 25.5, 
    forwardRotate := 127.5, 
    forwardSpeed := 102, 
    lfLeftVal := 0.0, 
    lfRightVal := 0.0, 
    out1 := 0.0, 
    out2 := 0.0, 
    out3 := 0.0, 
    out4 := 0.0, 
    servoLeftVal := 0.0, 
    servoRightVal := 0.0
  #)

  %-- leave/enter functions
  enter(m: Mode)(st: State): State = st WITH [ mode := m ]
  leave(m: Mode)(st: State): State = st WITH [ previous_mode := m ]

  %-- triggers
  per_accellerate(st: State): bool = (mode(st) = Auto AND ( true ))
    OR (mode(st) = Manual AND ( true ))
  accellerate(st: (per_accellerate)): State =
    COND
     mode(st) = Auto AND ( true )
      -> LET st = leave(Auto)(st),
             st = st WITH [ servoLeftVal := inc_speed(servoLeftVal(st),10) ],
             st = st WITH [ servoRightVal := inc_speed(servoRightVal(st),10) ],
             st = st WITH [ out1 := 1.0 ],
             st = st WITH [ out2 := 0.0 ],
             st = st WITH [ out3 := 1.0 ],
             st = st WITH [ out4 := 0.0 ]
          IN enter(Manual)(st),
     mode(st) = Manual AND ( true )
      -> LET st = leave(Manual)(st),
             st = st WITH [ servoLeftVal := inc_speed(servoLeftVal(st),10) ],
             st = st WITH [ servoRightVal := inc_speed(servoRightVal(st),10) ],
             st = st WITH [ out1 := 1.0 ],
             st = st WITH [ out2 := 0.0 ],
             st = st WITH [ out3 := 1.0 ],
             st = st WITH [ out4 := 0.0 ]
          IN enter(Manual)(st),
     ELSE -> st
    ENDCOND

  per_autopilot(st: State): bool = (mode(st) = Manual AND ( true ))
  autopilot(st: (per_autopilot)): State =
    COND
     mode(st) = Manual AND ( true )
      -> LET st = leave(Manual)(st),
             st = st WITH [ servoLeftVal := servoLeftVal(st) ],
             st = st WITH [ servoRightVal := servoRightVal(st) ]
          IN enter(Auto)(st),
     ELSE -> st
    ENDCOND

  per_brake(st: State): bool = (mode(st) = Auto AND ( true ))
    OR (mode(st) = Manual AND ( true ))
  brake(st: (per_brake)): State =
    COND
     mode(st) = Auto AND ( true )
      -> LET st = leave(Auto)(st),
			 st = st WITH [ servoLeftVal := 0 ],
             st = st WITH [ servoRightVal := 0 ],
             st = st WITH [ out1 := 0.0 ],
             st = st WITH [ out2 := 0.0 ],
             st = st WITH [ out3 := 0.0 ],
             st = st WITH [ out4 := 0.0 ]
          IN enter(Manual)(st),
     mode(st) = Manual AND ( true )
      -> LET st = leave(Manual)(st),
             st = st WITH [ servoLeftVal := 0 ],
             st = st WITH [ servoRightVal := 0 ],
             st = st WITH [ out1 := 0.0 ],
             st = st WITH [ out2 := 0.0 ],
             st = st WITH [ out3 := 0.0 ],
             st = st WITH [ out4 := 0.0 ]
          IN enter(Manual)(st),
     ELSE -> st
    ENDCOND

  per_tick(st: State): bool = (mode(st) = Auto AND ( lfRightVal(st) <= LSR_THRESHOLD AND lfLeftVal(st) <= LSR_THRESHOLD ))
    OR (mode(st) = Auto AND ( lfRightVal(st) <= LSR_THRESHOLD AND lfLeftVal(st) > LSR_THRESHOLD ))
    OR (mode(st) = Auto AND ( lfRightVal(st) > LSR_THRESHOLD AND lfLeftVal(st) <= LSR_THRESHOLD ))
    OR (mode(st) = Auto AND ( lfRightVal(st) > LSR_THRESHOLD AND lfLeftVal(st) > LSR_THRESHOLD ))
    OR (mode(st) = Manual AND ( true ))
  tick(st: (per_tick)): State =
    COND
     mode(st) = Auto AND ( lfRightVal(st) <= LSR_THRESHOLD AND lfLeftVal(st) <= LSR_THRESHOLD )
      -> LET st = leave(Auto)(st),
             st = st WITH [ servoLeftVal := servoLeftVal(st) ],
             st = st WITH [ servoRightVal := servoRightVal(st) ],
             st = st WITH [ out1 := out1(st) ],
             st = st WITH [ out2 := out2(st) ],
             st = st WITH [ out3 := out3(st) ],
             st = st WITH [ out4 := out4(st) ]
          IN enter(Auto)(st),
     mode(st) = Auto AND ( lfRightVal(st) <= LSR_THRESHOLD AND lfLeftVal(st) > LSR_THRESHOLD )
      -> LET st = leave(Auto)(st),
             st = st WITH [ servoLeftVal := forwardRotate(st) ],
             st = st WITH [ servoRightVal := backwardRotate(st) ],
             st = st WITH [ out1 := 1.0 ],
             st = st WITH [ out2 := 0.0 ],
             st = st WITH [ out3 := 0.0 ],
             st = st WITH [ out4 := 1.0 ]
          IN enter(Auto)(st),
     mode(st) = Auto AND ( lfRightVal(st) > LSR_THRESHOLD AND lfLeftVal(st) <= LSR_THRESHOLD )
      -> LET st = leave(Auto)(st),
             st = st WITH [ servoLeftVal := backwardRotate(st) ],
             st = st WITH [ servoRightVal := forwardRotate(st) ],
             st = st WITH [ out1 := 0.0 ],
             st = st WITH [ out2 := 1.0 ],
             st = st WITH [ out3 := 1.0 ],
             st = st WITH [ out4 := 0.0 ]
          IN enter(Auto)(st),
     mode(st) = Auto AND ( lfRightVal(st) > LSR_THRESHOLD AND lfLeftVal(st) > LSR_THRESHOLD )
      -> LET st = leave(Auto)(st),
             st = st WITH [ servoLeftVal := forwardSpeed(st) ],
             st = st WITH [ servoRightVal := forwardSpeed(st) ],
             st = st WITH [ out1 := 1.0 ],
             st = st WITH [ out2 := 0.0 ],
             st = st WITH [ out3 := 1.0 ],
             st = st WITH [ out4 := 0.0 ]
          IN enter(Auto)(st),
     mode(st) = Manual AND ( true )
      -> LET st = leave(Manual)(st),
             st = st WITH [ servoLeftVal := servoLeftVal(st) ],
             st = st WITH [ servoRightVal := servoRightVal(st) ]
          IN enter(Manual)(st),
     ELSE -> st
    ENDCOND

  per_turnLeft(st: State): bool = (mode(st) = Manual AND ( true ))
    OR (mode(st) = Auto AND ( true ))
  turnLeft(st: (per_turnLeft)): State =
    COND
     mode(st) = Manual AND ( true )
      -> LET st = leave(Manual)(st),
             st = st WITH [ servoLeftVal := backwardRotate(st)  ],
             st = st WITH [ servoRightVal := forwardRotate(st)  ],
             st = st WITH [ out1 := 0.0 ],
             st = st WITH [ out2 := 1.0 ],
             st = st WITH [ out3 := 1.0 ],
             st = st WITH [ out4 := 0.0 ]
          IN enter(Manual)(st),
     mode(st) = Auto AND ( true )
      -> LET st = leave(Auto)(st),
             st = st WITH [ servoLeftVal := backwardRotate(st)  ],
             st = st WITH [ servoRightVal := forwardRotate(st)  ],
             st = st WITH [ out1 := 0.0 ],
             st = st WITH [ out2 := 1.0 ],
             st = st WITH [ out3 := 1.0 ],
             st = st WITH [ out4 := 0.0 ]
          IN enter(Manual)(st),
     ELSE -> st
    ENDCOND

  per_turnRight(st: State): bool = (mode(st) = Auto AND ( true ))
    OR (mode(st) = Manual AND ( true ))
  turnRight(st: (per_turnRight)): State =
    COND
     mode(st) = Auto AND ( true )
      -> LET st = leave(Auto)(st),
             st = st WITH [ servoLeftVal := forwardRotate(st)  ],
             st = st WITH [ servoRightVal := backwardRotate(st)  ],
             st = st WITH [ out1 := 1.0 ],
             st = st WITH [ out2 := 0.0 ],
             st = st WITH [ out3 := 0.0 ],
             st = st WITH [ out4 := 1.0 ]
          IN enter(Manual)(st),
     mode(st) = Manual AND ( true )
      -> LET st = leave(Manual)(st),
             st = st WITH [ servoLeftVal := forwardRotate(st)  ],
             st = st WITH [ servoRightVal := backwardRotate(st)  ],
             st = st WITH [ out1 := 1.0 ],
             st = st WITH [ out2 := 0.0 ],
             st = st WITH [ out3 := 0.0 ],
             st = st WITH [ out4 := 1.0 ]
          IN enter(Manual)(st),
     ELSE -> st
    ENDCOND

 kth_step(K:nat):RECURSIVE State= 
   IF (K=0) THEN
    init
   ELSE
    tick(kth_step(K-1))
   ENDIF
  MEASURE K

  no_shortcircuits : THEOREM
  FORALL (K:nat): NOT( ( out1(kth_step(K)) = 1 AND out2(kth_step(K)) = 1) OR ( out3(kth_step(K)) = 1 AND out4(kth_step(K)) = 1))

  always_auto : THEOREM
  FORALL (K:nat): mode(kth_step(K)) = Auto

 END line_following_robot_Arduino_for_FMI
